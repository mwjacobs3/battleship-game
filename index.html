<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Battleship Game</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel">
        const { useState, useEffect } = React;
        
        // Lucide React icons as inline SVG components
        const Ship = ({ className }) => (
            <svg className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <path d="M2 21c.6.5 1.2 1 2.5 1 2.5 0 2.5-2 5-2 1.3 0 1.9.5 2.5 1 .6.5 1.2 1 2.5 1 2.5 0 2.5-2 5-2 1.3 0 1.9.5 2.5 1"/>
                <path d="M19.38 20A11.6 11.6 0 0 0 21 14l-9-4-9 4c0 2.9.94 5.34 2.81 7.76"/>
                <path d="M19 13V7a2 2 0 0 0-2-2H7a2 2 0 0 0-2 2v6"/>
                <path d="M12 10v4"/>
                <path d="M12 2v3"/>
            </svg>
        );
        
        const Target = ({ className }) => (
            <svg className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <circle cx="12" cy="12" r="10"/>
                <circle cx="12" cy="12" r="6"/>
                <circle cx="12" cy="12" r="2"/>
            </svg>
        );
        
        const Anchor = ({ className }) => (
            <svg className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <circle cx="12" cy="5" r="3"/>
                <line x1="12" x2="12" y1="22" y2="8"/>
                <path d="M5 12H2a10 10 0 0 0 20 0h-3"/>
            </svg>
        );

        const GRID_SIZE = 10;
        const SHIPS = [
          { name: 'Carrier', size: 5, icon: '🚢' },
          { name: 'Battleship', size: 4, icon: '⛴️' },
          { name: 'Cruiser', size: 3, icon: '🛳️' },
          { name: 'Submarine', size: 3, icon: '🚤' },
          { name: 'Destroyer', size: 2, icon: '⛵' }
        ];

        const BattleshipGame = () => {
          const [gameState, setGameState] = useState('setup');
          const [playerBoard, setPlayerBoard] = useState(null);
          const [aiBoard, setAiBoard] = useState(null);
          const [playerShots, setPlayerShots] = useState([]);
          const [aiShots, setAiShots] = useState([]);
          const [currentShipIndex, setCurrentShipIndex] = useState(0);
          const [shipOrientation, setShipOrientation] = useState('horizontal');
          const [message, setMessage] = useState('Place your Carrier (5 spaces)');
          const [playerShipsRemaining, setPlayerShipsRemaining] = useState(5);
          const [aiShipsRemaining, setAiShipsRemaining] = useState(5);
          const [aiTargetMode, setAiTargetMode] = useState({ active: false, hits: [] });

          useEffect(() => {
            initializeBoards();
          }, []);

          const createEmptyBoard = () => {
            return Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(null));
          };

          const initializeBoards = () => {
            const emptyBoard = createEmptyBoard();
            setPlayerBoard(emptyBoard.map(row => [...row]));
            
            const aiEmptyBoard = createEmptyBoard();
            const aiPlacedBoard = placeAiShips(aiEmptyBoard);
            setAiBoard(aiPlacedBoard);
          };

          const placeAiShips = (board) => {
            const newBoard = board.map(row => [...row]);
            
            SHIPS.forEach((ship, index) => {
              let placed = false;
              let attempts = 0;
              
              while (!placed && attempts < 100) {
                const orientation = Math.random() > 0.5 ? 'horizontal' : 'vertical';
                const row = Math.floor(Math.random() * GRID_SIZE);
                const col = Math.floor(Math.random() * GRID_SIZE);
                
                if (canPlaceShip(newBoard, row, col, ship.size, orientation)) {
                  for (let i = 0; i < ship.size; i++) {
                    const r = orientation === 'horizontal' ? row : row + i;
                    const c = orientation === 'horizontal' ? col + i : col;
                    newBoard[r][c] = index;
                  }
                  placed = true;
                }
                attempts++;
              }
              
              if (!placed) {
                console.warn(`Failed to place ${ship.name} after ${attempts} attempts`);
              }
            });
            
            return newBoard;
          };

          const canPlaceShip = (board, row, col, size, orientation) => {
            if (!board || !board[0]) return false;
            
            if (orientation === 'horizontal') {
              if (col + size > GRID_SIZE) return false;
              for (let i = 0; i < size; i++) {
                if (board[row][col + i] !== null) return false;
              }
            } else {
              if (row + size > GRID_SIZE) return false;
              for (let i = 0; i < size; i++) {
                if (board[row + i][col] !== null) return false;
              }
            }
            return true;
          };

          const handlePlayerPlacement = (row, col) => {
            if (gameState !== 'setup' || !playerBoard) return;
            
            const ship = SHIPS[currentShipIndex];
            
            if (canPlaceShip(playerBoard, row, col, ship.size, shipOrientation)) {
              const newBoard = playerBoard.map(row => [...row]);
              
              for (let i = 0; i < ship.size; i++) {
                const r = shipOrientation === 'horizontal' ? row : row + i;
                const c = shipOrientation === 'horizontal' ? col + i : col;
                newBoard[r][c] = currentShipIndex;
              }
              
              setPlayerBoard(newBoard);
              
              if (currentShipIndex < SHIPS.length - 1) {
                setCurrentShipIndex(currentShipIndex + 1);
                setMessage(`Place your ${SHIPS[currentShipIndex + 1].name} (${SHIPS[currentShipIndex + 1].size} spaces)`);
              } else {
                setGameState('playing');
                setMessage('All ships placed! Click on the AI board to attack!');
              }
            } else {
              setMessage(`Cannot place ship here. Try again.`);
            }
          };

          const handlePlayerShot = (row, col) => {
            if (gameState !== 'playing' || !aiBoard) return;
            
            const shotKey = `${row},${col}`;
            if (playerShots.includes(shotKey)) {
              setMessage('You already shot here!');
              return;
            }
            
            const newPlayerShots = [...playerShots, shotKey];
            setPlayerShots(newPlayerShots);
            
            const hit = aiBoard[row][col] !== null;
            
            if (hit) {
              const shipIndex = aiBoard[row][col];
              const shipHits = newPlayerShots.filter(shot => {
                const [r, c] = shot.split(',').map(Number);
                return aiBoard[r] && aiBoard[r][c] === shipIndex;
              });
              
              if (shipHits.length === SHIPS[shipIndex].size) {
                setMessage(`You sunk the AI's ${SHIPS[shipIndex].name}!`);
                const newAiShipsRemaining = aiShipsRemaining - 1;
                setAiShipsRemaining(newAiShipsRemaining);
                
                if (newAiShipsRemaining === 0) {
                  setGameState('won');
                  setMessage('🎉 You won! You sunk all AI ships!');
                  return;
                }
              } else {
                setMessage('Hit! 💥');
              }
            } else {
              setMessage('Miss! 💧');
            }
            
            setTimeout(() => {
              aiTurn(newPlayerShots);
            }, 1000);
          };

          const aiTurn = (currentPlayerShots) => {
            if (!playerBoard) return;
            
            let row, col, shotKey;
            let attempts = 0;
            
            if (aiTargetMode.active && aiTargetMode.hits.length > 0) {
              const shot = getSmartAiShot();
              if (shot) {
                row = shot.row;
                col = shot.col;
                shotKey = `${row},${col}`;
              }
            }
            
            if (!shotKey) {
              do {
                row = Math.floor(Math.random() * GRID_SIZE);
                col = Math.floor(Math.random() * GRID_SIZE);
                shotKey = `${row},${col}`;
                attempts++;
              } while (aiShots.includes(shotKey) && attempts < 100);
            }
            
            const newAiShots = [...aiShots, shotKey];
            setAiShots(newAiShots);
            
            const hit = playerBoard[row][col] !== null;
            
            if (hit) {
              const shipIndex = playerBoard[row][col];
              const newTargetMode = {
                active: true,
                hits: [...aiTargetMode.hits, { row, col }]
              };
              
              const shipHits = newAiShots.filter(shot => {
                const [r, c] = shot.split(',').map(Number);
                return playerBoard[r] && playerBoard[r][c] === shipIndex;
              });
              
              if (shipHits.length === SHIPS[shipIndex].size) {
                setMessage(`AI sunk your ${SHIPS[shipIndex].name}! 😱`);
                const newPlayerShipsRemaining = playerShipsRemaining - 1;
                setPlayerShipsRemaining(newPlayerShipsRemaining);
                
                newTargetMode.active = false;
                newTargetMode.hits = [];
                
                if (newPlayerShipsRemaining === 0) {
                  setGameState('lost');
                  setMessage('💀 Game Over! AI sunk all your ships!');
                  setAiTargetMode(newTargetMode);
                  return;
                }
              } else {
                setMessage('AI hit your ship! 💥');
              }
              
              setAiTargetMode(newTargetMode);
            } else {
              setMessage('AI missed! 💧');
            }
          };

          const getSmartAiShot = () => {
            const hits = aiTargetMode.hits;
            if (hits.length === 0) return null;
            
            if (hits.length === 1) {
              const { row, col } = hits[0];
              const directions = [
                { row: row - 1, col },
                { row: row + 1, col },
                { row, col: col - 1 },
                { row, col: col + 1 }
              ];
              
              for (const dir of directions) {
                if (dir.row >= 0 && dir.row < GRID_SIZE && dir.col >= 0 && dir.col < GRID_SIZE) {
                  const shotKey = `${dir.row},${dir.col}`;
                  if (!aiShots.includes(shotKey)) {
                    return dir;
                  }
                }
              }
            } else {
              const sortedHits = [...hits].sort((a, b) => a.row === b.row ? a.col - b.col : a.row - b.row);
              const first = sortedHits[0];
              const last = sortedHits[sortedHits.length - 1];
              
              if (first.row === last.row) {
                const directions = [
                  { row: first.row, col: first.col - 1 },
                  { row: last.row, col: last.col + 1 }
                ];
                
                for (const dir of directions) {
                  if (dir.col >= 0 && dir.col < GRID_SIZE) {
                    const shotKey = `${dir.row},${dir.col}`;
                    if (!aiShots.includes(shotKey)) {
                      return dir;
                    }
                  }
                }
              } else {
                const directions = [
                  { row: first.row - 1, col: first.col },
                  { row: last.row + 1, col: last.col }
                ];
                
                for (const dir of directions) {
                  if (dir.row >= 0 && dir.row < GRID_SIZE) {
                    const shotKey = `${dir.row},${dir.col}`;
                    if (!aiShots.includes(shotKey)) {
                      return dir;
                    }
                  }
                }
              }
            }
            
            return null;
          };

          const resetGame = () => {
            setGameState('setup');
            setCurrentShipIndex(0);
            setShipOrientation('horizontal');
            setPlayerShots([]);
            setAiShots([]);
            setMessage('Place your Carrier (5 spaces)');
            setPlayerShipsRemaining(5);
            setAiShipsRemaining(5);
            setAiTargetMode({ active: false, hits: [] });
            initializeBoards();
          };

          const renderCell = (row, col, isPlayerBoard) => {
            if (!playerBoard || !aiBoard) return null;
            
            const board = isPlayerBoard ? playerBoard : aiBoard;
            const shots = isPlayerBoard ? aiShots : playerShots;
            const shotKey = `${row},${col}`;
            const wasShot = shots.includes(shotKey);
            const hasShip = board[row] && board[row][col] !== null;
            
            let cellClass = 'w-8 h-8 border border-blue-300 flex items-center justify-center cursor-pointer transition-colors ';
            let content = null;
            
            if (wasShot) {
              if (hasShip) {
                cellClass += 'bg-red-500';
                content = React.createElement(Target, { className: "w-4 h-4 text-white" });
              } else {
                cellClass += 'bg-blue-200';
                content = '•';
              }
            } else if (isPlayerBoard && hasShip && gameState !== 'setup') {
              cellClass += 'bg-gray-400';
              content = React.createElement(Ship, { className: "w-4 h-4 text-gray-700" });
            } else if (gameState === 'setup' && isPlayerBoard && hasShip) {
              cellClass += 'bg-gray-400';
              content = React.createElement(Ship, { className: "w-4 h-4 text-gray-700" });
            } else {
              cellClass += 'bg-blue-50 hover:bg-blue-100';
            }
            
            const handleClick = () => {
              if (isPlayerBoard && gameState === 'setup') {
                handlePlayerPlacement(row, col);
              } else if (!isPlayerBoard && gameState === 'playing') {
                handlePlayerShot(row, col);
              }
            };
            
            return React.createElement('div', {
              key: `${row}-${col}`,
              className: cellClass,
              onClick: handleClick
            }, content);
          };

          if (!playerBoard || !aiBoard) {
            return React.createElement('div', {
              className: "min-h-screen bg-gradient-to-b from-blue-900 to-blue-700 p-8 flex items-center justify-center"
            }, React.createElement('div', { className: "text-white text-2xl" }, "Loading game..."));
          }

          return React.createElement('div', {
            className: "min-h-screen bg-gradient-to-b from-blue-900 to-blue-700 p-8"
          }, 
            React.createElement('div', { className: "max-w-6xl mx-auto" },
              React.createElement('div', { className: "text-center mb-8" },
                React.createElement('h1', { className: "text-5xl font-bold text-white mb-2 flex items-center justify-center gap-3" },
                  React.createElement(Anchor, { className: "w-12 h-12" }),
                  'Battleship',
                  React.createElement(Anchor, { className: "w-12 h-12" })
                ),
                React.createElement('p', { className: "text-blue-200 text-lg" }, message)
              ),
              
              gameState === 'setup' && React.createElement('div', { className: "bg-white rounded-lg p-4 mb-6 text-center" },
                React.createElement('p', { className: "font-semibold mb-2" }, `Placing: ${SHIPS[currentShipIndex].name} (${SHIPS[currentShipIndex].size} spaces)`),
                React.createElement('button', {
                  onClick: () => setShipOrientation(shipOrientation === 'horizontal' ? 'vertical' : 'horizontal'),
                  className: "bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700 transition-colors"
                }, `Orientation: ${shipOrientation === 'horizontal' ? '→ Horizontal' : '↓ Vertical'}`)
              ),
              
              React.createElement('div', { className: "grid grid-cols-1 md:grid-cols-2 gap-8" },
                React.createElement('div', { className: "bg-white rounded-lg p-6" },
                  React.createElement('h2', { className: "text-2xl font-bold mb-4 text-center" }, "Your Board"),
                  React.createElement('div', { className: "flex justify-center mb-2" },
                    React.createElement('div', { className: "grid grid-cols-10 gap-0" },
                      Array(GRID_SIZE).fill(null).map((_, row) =>
                        Array(GRID_SIZE).fill(null).map((_, col) => renderCell(row, col, true))
                      )
                    )
                  ),
                  React.createElement('p', { className: "text-center text-sm text-gray-600" }, `Ships Remaining: ${playerShipsRemaining}`)
                ),
                
                React.createElement('div', { className: "bg-white rounded-lg p-6" },
                  React.createElement('h2', { className: "text-2xl font-bold mb-4 text-center" }, "AI Board"),
                  React.createElement('div', { className: "flex justify-center mb-2" },
                    React.createElement('div', { className: "grid grid-cols-10 gap-0" },
                      Array(GRID_SIZE).fill(null).map((_, row) =>
                        Array(GRID_SIZE).fill(null).map((_, col) => renderCell(row, col, false))
                      )
                    )
                  ),
                  React.createElement('p', { className: "text-center text-sm text-gray-600" }, `Ships Remaining: ${aiShipsRemaining}`)
                )
              ),
              
              (gameState === 'won' || gameState === 'lost') && React.createElement('div', { className: "text-center mt-8" },
                React.createElement('button', {
                  onClick: resetGame,
                  className: "bg-green-600 text-white px-8 py-3 rounded-lg text-xl font-bold hover:bg-green-700 transition-colors"
                }, "Play Again")
              ),
              
              React.createElement('div', { className: "bg-white rounded-lg p-6 mt-8" },
                React.createElement('h3', { className: "text-xl font-bold mb-3" }, "How to Play:"),
                React.createElement('ol', { className: "list-decimal list-inside space-y-2 text-gray-700" },
                  React.createElement('li', null, React.createElement('strong', null, 'Setup Phase:'), ' Place all 5 ships on your board by clicking cells. Toggle orientation with the button.'),
                  React.createElement('li', null, React.createElement('strong', null, 'Attack Phase:'), ' Click cells on the AI board to attack. Hits show red with a target icon, misses show blue with a dot.'),
                  React.createElement('li', null, React.createElement('strong', null, 'AI Turn:'), ' After each of your shots, the AI will automatically take a turn.'),
                  React.createElement('li', null, React.createElement('strong', null, 'Win Condition:'), ' Sink all enemy ships before they sink yours!')
                )
              )
            )
          );
        };

        ReactDOM.render(
          React.createElement(BattleshipGame),
          document.getElementById('root')
        );
    </script>
</body>
</html>
